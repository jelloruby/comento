## 2주차


### 📗 2주차 과제를 수행하며
1주차 과제에서 마크업한 것을 토대로 2주차에서 모바일 기준 css를 먼저 작성했다.
반응형을 다뤄보긴 했지만 시안을 받아서 작성해본 것은 처음이었기 때문에 고려해야할 사항이 많았다.

#### 시안의 크기
css를 작성하기에 앞서 디자인 분석이 필요했다.
모바일 시안의 전체 크기를 보니 640px로 되어 있었는데, 
모바일과 태블릿까지 적용되는 크기가 보통 320px ~ 767px 정도라고 생각했기 때문에 이해가 가지 않았다.
[멘토님이 보내주신 참고 링크](https://front8062.tistory.com/27)를 확인해보니 해상도 문제였다.


- ratio : 모바일 기기의 해상도는 pc와 달리 ratio의 개념을 사용한다. ratio가 2일 경우에 1px의 크기에 2px이 들어가는 해상도라는 뜻이다. ([출처](https://front8062.tistory.com/27))


ratio의 개념이 익숙치 않아서 검색을 해보니 기기 픽셀 비율이 존재한다는 것을 알게 되었다.


- 기기 픽셀 비율 : 물리적 해상도 / 논리적 해상도 ([출처](https://abcdqbbq.tistory.com/47))


모바일 기기의 '물리적 해상도'를 기준으로 '논리적 해상도'는 모바일 기기의 ratio의 비율만큼 줄어든다.
css를 작성할 때는 '논리적 해상도'를 기준으로 작성해야만 모바일 기기에서 화면의 이상 없이 볼 수 있게 된다.



### 📗 2주차 과제 피드백


1주차에 제출한 마크업에서 말씀해 주신 것을 직접 코드를 보며 한번 더 짚어주셨고, 2주차에 작성한 CSS에 대한 피드백을 받는 시간을 가졌다.  


#### - 수정한 내용
- 불필요한 클래스 정리
    ```html
    <ul class="gnb_dropdown_list">
        <li class="gnb_dropdown_list_item">
            <a href="">TECHNICAL</a>
        </li>
        <li class="gnb_dropdown_list_item">
            <a href="">CUSTOMER SERVICE</a>
        </li>
    </ul>
    ```
    위의 코드를 예로 들면, 모든 ul 태그 안의 li 태그에 클래스명을 붙였고, 부모 태그의 클래스명과 겹치게 작성했다.


    ```css
    /* 1 */
    .gnb_dropdown_list > .gnb_dropdown_list_item { ... }
    .gnb_dropdown_list_item { ... }

    /* 2 */
    .gnb_dropdown_list > li { ... }
    ```
    이전에는 모든 태그에 클래스명을 작성하는 것이 좋다고 생각하여 작성했지만, css 코드를 작성할 때 1번 같은 경우 너무 코드가 길고 가독성이 좋지 않아보였다.
    2번 같이 처리하면 부모 태그가 어느 태그인지도 확실히 할 수 있고, 가독성이 좋다고 생각하여 불필요한 클래스를 정리했다.
    마구잡이로 줄인다기 보다 코드 한 글자도 자원이기 때문에 불필요한 것을 줄여나가는 것이 중요하다고 느꼈다.


#### - 추가 해야할 내용
1. __이미지 스프라이트 기법 적용__

    모든 아이콘을 img 태그로 작성했는데 [1주차 피드백 3번](https://github.com/jelloruby/comento/tree/1_comento_UI%EA%B0%9C%EB%B0%9C/1_UI%EA%B0%9C%EB%B0%9C/1%EC%A3%BC%EC%B0%A8)에도 있다시피, 아이콘을 디자인적인 부분이기 때문에 css에서 처리하는 것이 가능하다. 다양한 방법이 있지만 [이미지 스프라이트 기법](http://tcpschool.com/css/css_basic_imageSprites)이 존재한다는 것을 알았다.

    - 이미지 스프라이트 기법 : 여러 개의 이미지를 하나의 이미지로 합쳐서 관리하는 이미지를 의미한다.

        합친 이미지를 css의 background에 이미지를 넣어서 background-position으로 해당하는 이미지의 위치를 잡아 주는 것이다. 이렇게 하면 일일이 이미지를 넣어주는 것보다 성능적인 부분에서도 웹 페이지의 로딩 시간을 단축할 수 있다.


2. __내부 텍스트 숨김 처리__

    [1주차 피드백 4번](https://github.com/jelloruby/comento/tree/1_comento_UI%EA%B0%9C%EB%B0%9C/1_UI%EA%B0%9C%EB%B0%9C/1%EC%A3%BC%EC%B0%A8)을 토대로 내부 텍스트를 없앨 때 `{ text-indent: -9999px }`를 넣어서 없앴다. 하지만 이 경우에 정확한 위치 표현이 어려워서 레이아웃에도 문제가 생기고, tab으로 포커싱이 되는 태그일 경우에 스크린 밖에 위치 하기 때문에 혼란을 줄 수 있다고 한다. (이렇게 적용한 태그가 모두 button 태그 였다... 😱) 내부 텍스트를 숨김 처리 하는 데에는 많은 방법이 있다.


    1. BAD

        아래와 같은 방법은 스크린 리더가 인식하지 못한다.

        ```css
        /* 투명도를 0으로 주는 것과 동일하게 화면에서 사라지지만, 스크린 리더 인식 안함 */
        visibility: hidden;

        /* 요소가 아예 없는 것으로 인식 */
        display: none;

        /* 요소의 사이즈를 0으로 만들면 스크린 리더 인식 안함 */
        width: 0;
        height: 0;
        font-size: 0;
        line-height: 0;
        ```

    2. SO SO 

        스크린 리더가 인식하지만 레이아웃이나 성능 등에 이슈가 발생할 수 있기 때문에, 상황에 맞게 사용해야 한다.

        ```css
        /* 투명해진 것 뿐, 위치를 그대로 잡고 있기 때문에 단독으로 사용 불가능 */
        opacity: 0;

        /* 전체 레이어의 크기가 지나치게 크게 잡힘: 성능 이슈  */
        text-indent: -9999px;

        /* position 속성 추가해야 함: 성능 이슈  */
        z-index: -1;
        ```

    3. BEST

        스크린 리더가 인식하면서 레이아웃이나 성능 등에 영향을 미치지 않는 방법으로, 아래 속성들을 조합해서 사용한다. HTML 전체적으로 많이 쓰이기 때문에 클래스로 처리하는 것이 효율적이다.

        ```html
        <span class="blind">숨김 텍스트</span>
        ```
        ```css
        .blind {
            /* 레이아웃에 영향을 끼치지 않도록 */
            position: absolute;

            /* 스크린 리더가 읽을 수 있도록 */
            width: 1px;
            height: 1px;

            /* 눈에 보이는 부분을 제거 */
            clip: rect(0 0 0 0);
            margin: -1px;
            overflow: hidden;
        }
        ```

    [출처 : 부스트코스 웹 UI 개발 > 3. HTML&CSS활용 | 요소 숨김 처리](https://www.boostcourse.org/web344/lecture/47663/?isDesc=false)
